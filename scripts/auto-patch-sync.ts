#!/usr/bin/env bun
import { readFileSync, existsSync, readdirSync, statSync } from "node:fs";
import { join, dirname } from "path";
import { $ } from "bun";

interface PatchInfo {
  package: string;
  version: string;
  patchFile: string;
  lastModified: Date;
}

async function getCurrentPatches(): Promise<PatchInfo[]> {
  const patches: PatchInfo[] = [];
  const patchesDir = "patches";

  if (!existsSync(patchesDir)) {
    return patches;
  }

  function scanDir(dir: string) {
    const entries = readdirSync(dir);
    for (const entry of entries) {
      const fullPath = join(dir, entry);
      const stat = statSync(fullPath);

      if (stat.isDirectory()) {
        scanDir(fullPath);
      } else if (entry.endsWith(".patch")) {
        // Extract package and version from filename like "react@18.2.0.patch"
        const match = entry.match(/^(.+)@(.+)\.patch$/);
        if (match) {
          const [, pkg, version] = match;
          patches.push({
            package: pkg,
            version,
            patchFile: fullPath,
            lastModified: stat.mtime
          });
        }
      }
    }
  }

  scanDir(patchesDir);
  return patches;
}

async function getPackageJsonPatches(): Promise<Record<string, string>> {
  const pkg = JSON.parse(readFileSync("package.json", "utf-8"));
  return pkg.patchedDependencies || {};
}

async function checkPatchApplicability(patchFile: string): Promise<boolean> {
  try {
    const result = await $`patch --dry-run -p1 < ${patchFile}`.nothrow();
    return result.exitCode === 0;
  } catch {
    return false;
  }
}

async function syncPatches() {
  console.log("ğŸ”„ Starting patch synchronization...\n");

  const currentPatches = await getCurrentPatches();
  const packageJsonPatches = await getPackageJsonPatches();

  console.log(`ğŸ“Š Found ${currentPatches.length} patch files`);
  console.log(`ğŸ“¦ Found ${Object.keys(packageJsonPatches).length} patchedDependencies entries\n`);

  // Check for patches in package.json but missing files
  console.log("ğŸ” Checking for missing patch files...");
  for (const [pkg, patchPath] of Object.entries(packageJsonPatches)) {
    if (!existsSync(patchPath)) {
      console.log(`   âŒ MISSING: ${pkg} -> ${patchPath}`);
    } else {
      console.log(`   âœ… Found: ${pkg} -> ${patchPath}`);
    }
  }

  // Check for patch files not in package.json
  console.log("\nğŸ” Checking for orphaned patch files...");
  const packageJsonPaths = new Set(Object.values(packageJsonPatches));

  for (const patch of currentPatches) {
    if (!packageJsonPaths.has(patch.patchFile)) {
      console.log(`   âš ï¸  ORPHANED: ${patch.package}@${patch.version} -> ${patch.patchFile}`);
    }
  }

  // Check patch applicability
  console.log("\nğŸ” Checking patch applicability...");
  let applicableCount = 0;
  let conflictCount = 0;

  for (const patch of currentPatches) {
    const applicable = await checkPatchApplicability(patch.patchFile);
    if (applicable) {
      console.log(`   âœ… Applicable: ${patch.package}@${patch.version}`);
      applicableCount++;
    } else {
      console.log(`   âŒ Conflicts: ${patch.package}@${patch.version}`);
      conflictCount++;
    }
  }

  // Check for upstream updates
  console.log("\nğŸ” Checking for upstream updates...");
  const outdatedPatches: PatchInfo[] = [];

  for (const patch of currentPatches) {
    try {
      // Get current version from npm
      const npmInfo = await $`npm view ${patch.package} version`.text();
      const currentVersion = npmInfo.trim();

      if (currentVersion !== patch.version) {
        console.log(`   ğŸ“ˆ Update available: ${patch.package}@${patch.version} -> ${currentVersion}`);
        outdatedPatches.push(patch);
      }
    } catch (error) {
      console.log(`   âš ï¸  Could not check updates for ${patch.package}`);
    }
  }

  // Summary
  console.log("\nğŸ“ˆ Synchronization Summary:");
  console.log(`   Total patches: ${currentPatches.length}`);
  console.log(`   Applicable: ${applicableCount}`);
  console.log(`   Conflicts: ${conflictCount}`);
  console.log(`   Outdated: ${outdatedPatches.length}`);

  if (conflictCount > 0 || outdatedPatches.length > 0) {
    console.log("\nâš ï¸  Action required:");
    if (conflictCount > 0) {
      console.log(`   â€¢ Resolve ${conflictCount} patch conflicts`);
    }
    if (outdatedPatches.length > 0) {
      console.log(`   â€¢ Update ${outdatedPatches.length} outdated patches`);
    }
    process.exit(1);
  } else {
    console.log("\nâœ… All patches are synchronized and applicable!");
  }
}

async function createPatchTemplate() {
  const template = `# Example patch file
# This is generated by 'bun pm patch --commit package@version'
#
# To create a new patch:
# 1. Run: bun patch react
# 2. Edit files in node_modules/react/
# 3. Run: bun patch --commit react

diff --git a/path/to/file.js b/path/to/file.js
index abc123..def456 100644
--- a/path/to/file.js
+++ b/path/to/file.js
@@ -1,3 +1,3 @@
 // Original code
-console.log('original');
+console.log('patched');
 `.trim();

  console.log("ğŸ“ Patch file template:");
  console.log("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  console.log(template);
  console.log("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
}

async function main() {
  const args = process.argv.slice(2);

  if (args.includes("--template")) {
    await createPatchTemplate();
  } else {
    await syncPatches();
  }
}

if (import.meta.main) await main();
